import React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import App from '../src/app/index';
import path from 'path';
import fs from 'fs';

/* 
  The purpose of this file is to describe to express how to carry our rendering this react app on the server
  and serving it over a pipeable stream.
*/

// eslint-disable-next-line
const serverSideRender = function (url, res) {
  // Stream
  res.socket.on('error', (error) => {
    console.error('Fatal', error);
  });

  // 1. An artifact of the webpack build process is the build-stats.json containing our codesplit css and js.
  // We'll read from this file and collect only the core and vendor bundles for the first server load
  const BUILD_STATS = path.join(__dirname, 'static', 'build-stats.json');
  let buildStats = fs.readFileSync(BUILD_STATS);
  buildStats = JSON.parse(buildStats);
  let assets = {
    js: [],
    css: [],
  };

  // 2. Assemble only the core and vendor bundle paths for our first payload into js and css.
  Object.values(buildStats.assetsByChunkName).forEach((chunk) => {
    let onlyJavaScript = chunk.filter(
      (asset) => asset.endsWith('.js') && (asset.startsWith('static/js/core') || asset.startsWith('static/js/vendor')),
    );
    let onlyCSS = chunk.filter((asset) => asset.endsWith('.css') && asset.startsWith('static/css/core'));
    assets.js.push(...onlyJavaScript);
    assets.css.push(...onlyCSS);
  });

  // 3. Inject the client script (webpack needs to do this)
  // let state = {
  //   myState: 'isServer',
  // };

  let documentTitle = 'Aviator Server Build';

  const stream = renderToPipeableStream(<App assets={assets} location={url} title={documentTitle} isServer />, {
    // identifierPrefix?: string, // A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.
    // namespaceURI?: string, // A string with the root namespace URI for the stream. Defaults to regular HTML.
    // nonce?: string,  // A nonce string to allow scripts for script-src Content-Security-Policy.
    // bootstrapScriptContent?: string, // If specified, this string will be placed in an inline <script> tag.
    // bootstrapModules?: Array<string>, // Like bootstrapScripts, but emits <script type="module"> instead.
    // progressiveChunkSize?: number, // The number of bytes in a chunk.
    // onAllReady?: () => void,
    bootstrapScripts: assets.js,

    // Triggered when the shell finishes rendering up to the first Suspense boundary, ready to send a chunk to the client
    onShellReady() {
      // If something errored before we started streaming, we set the error code appropriately.
      res.setHeader('Content-type', 'text/html');
      stream.pipe(res);
    },

    // Triggered when something errored before we could complete the shell so we emit an alternative shell.
    onShellError() {
      res.statusCode = 500;
      res.send('<!doctype html><p>Loading...</p><script src="clientrender.js"></script>');
    },

    onError(x) {
      console.error(x);
    },
  });
};

// function handleErrors(fn) {
//   return async function (req, res, next) {
//     try {
//       return await fn(req, res);
//     } catch (x) {
//       next(x);
//     }
//   };
// }

// async function waitForWebpack() {
//   while (true) {
//     try {
//       readFileSync(path.resolve(__dirname, '../dist/static/build-stats.json'));
//       return;
//     } catch (err) {
//       console.log('Could not find webpack build output. Will retry in a second...');
//       await new Promise((resolve) => setTimeout(resolve, 1000));
//     }
//   }
// }

export default serverSideRender;
