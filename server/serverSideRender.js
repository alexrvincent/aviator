import React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import logError from './logError';
import App from '../src/app/index';
import path from 'path';
import fs from 'fs';

/* 
  The purpose of this file is to describe to express how to carry our rendering this react app to a healthy node stream.
  This will cover the process of generating the initial application shell and subsequent responses, as well as what to do
  when the shell cannot be created or some error occurs during the streaming process.
*/

// eslint-disable-next-line
const serverSideRender = function (url, res) {
  // Stream
  res.socket.on('error', (error) => {
    console.error('Fatal', error);
  });

  // Step 1: An artifact of the webpack build process is the build-stats.json containing our codesplit css and js.
  // We'll read from this file and collect only the core and vendor bundles for the first server load
  const BUILD_STATS = path.join(__dirname, 'static', 'build-stats.json');
  let buildStats = fs.readFileSync(BUILD_STATS);
  buildStats = JSON.parse(buildStats);
  let assets = {
    js: [],
    css: [],
  };

  // Step 2: Assemble only the core and vendor bundle paths for our first payload into js and css.
  Object.values(buildStats.assetsByChunkName).forEach((chunk) => {
    let onlyJavaScript = chunk.filter(
      (asset) => asset.endsWith('.js') && (asset.startsWith('static/js/core') || asset.startsWith('static/js/vendor')),
    );
    let onlyCSS = chunk.filter((asset) => asset.endsWith('.css') && asset.startsWith('static/css/core'));
    assets.js.push(...onlyJavaScript);
    assets.css.push(...onlyCSS);
  });

  // Step 3: Set the default response headers
  // TO-DO: Set default response headers
  let documentTitle = 'Aviator Server Build';

  // Step 4: Create the default server state
  let serverState = {
    myState: 'cameFromServer',
  };

  const inlineScripts = [
    `window.assetManifest = ${JSON.stringify(assets)};`,
    `window.__SERVER_STATE = ${JSON.stringify(serverState)};`,
  ];

  // Step 5: Create the node stream and pipe it into the express response
  const stream = renderToPipeableStream(<App assets={assets} location={url} title={documentTitle} isServer />, {
    // identifierPrefix?: string, // A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.
    // namespaceURI?: string, // A string with the root namespace URI for the stream. Defaults to regular HTML.
    // nonce?: string,  // A nonce string to allow scripts for script-src Content-Security-Policy.
    // progressiveChunkSize?: number, // The number of bytes in a chunk.
    // onAllReady?: () => void, // A callback that fires when all rendering is complete, including both the shell and all additional content. Use this instead of onShellReady for crawlers and static generation.
    bootstrapScriptContent: inlineScripts.join('\n'),
    bootstrapScripts: assets.js,

    // Triggered when the shell finishes rendering up to the first Suspense boundary, ready to send a chunk to the client
    onShellReady() {
      res.setHeader('Content-type', 'text/html');
      stream.pipe(res);
    },

    // Triggered when something errored before we could render the initial shell so we'll send the static client build to let the client attempt to render.
    onShellError(e) {
      // TO-DO: Send an error to a error logging service denoting that express failed to generate the initial shell on the server
      logError('renderToPipeableStream.onShellError()', e);
      res.statusCode = 500;

      const options = { root: 'dist' };

      // Attempt to send the webpack generated client build in place of the stream as a backup
      res.sendFile('app.html', options, function (e) {
        if (e) {
          logError('renderToPipeableStream.onShellError(), sendFile()', e);
          res.writeHead(500);
          res.end();
        }
      });
    },

    // Triggered when express runs into an arbitrary server error when streaming
    onError(e) {
      // TO-DO: Send an error to a error logging service denoting that express ran into a generic server error
      logError('renderToPipeableStream.onError()', e);
    },
  });
};

// function handleErrors(fn) {
//   return async function (req, res, next) {
//     try {
//       return await fn(req, res);
//     } catch (x) {
//       next(x);
//     }
//   };
// }

// async function waitForWebpack() {
//   while (true) {
//     try {
//       readFileSync(path.resolve(__dirname, '../dist/static/build-stats.json'));
//       return;
//     } catch (err) {
//       console.log('Could not find webpack build output. Will retry in a second...');
//       await new Promise((resolve) => setTimeout(resolve, 1000));
//     }
//   }
// }

export default serverSideRender;
